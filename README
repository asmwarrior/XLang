Variations of a Flex-Bison parser
based on "A COMPACT GUIDE TO LEX & YACC" by Tom Niemann

Copyright (C) 2011 Jerry Chen <mailto:onlyuser@gmail.com>

About:

    This is a parser "framework" inspired by Tom Niemann's excellent "Compact Guide
    to Lex/Yacc". 7 variations of Flex/Bison parser are presented, varying in
    feature richness.

    The first variation, "0_XLang_full", is a full-featured parser. With each
    successive variation, non-critical features are stripped until there is nothing
    left but a flex-less parser, "7_XLang_no-flex".

    feature <--                                                         --> feature
    rich                                                                    poor

    full, no-strings, no-comments, no-locations, no-reentrant, stdio, file, no-flex

    The order is chosen based on "usefulness" -- for instance, it is arguably more
    useful to have a reentrant parser than to have a non-reentrant parser, so the
    reentrant feature is enabled on the "feature rich" end. There's really no good
    reason one cannot cannot have both "comments" and "file input" enabled, or both
    "reentrant" and "hand-rolled lexer" enabled.

    The code is organized in a way that anyone unfamiliar with Flex/Bison can
    quickly isolate a variation that is most relevent, and most readily customizable
    to his/her specific requirements.

Variation vs Feature Table:

                 more                                                       less
                 critical <--                                           --> critical
+--------------+-------------+--------+-----------+-----------+----------+---------+
| variation    | lexer       | input  | reentrant | locations | comments | strings |
+--------------+-------------+--------+-----------+-----------+----------+---------+
| full         | flex        | buffer | yes       | yes       | yes      | yes     |
| no-strings   | flex        | buffer | yes       | yes       | yes      | no      |
| no-comments  | flex        | buffer | yes       | yes       | no       | no      |
| no-locations | flex        | buffer | yes       | no        | no       | no      |
| no-reentrant | flex        | buffer | no        | no        | no       | no      |
| stdio        | flex        | stdio  | no        | no        | no       | no      |
| file         | flex        | file   | no        | no        | no       | no      |
| no-flex      | hand-rolled | file   | no        | no        | no       | no      |
+--------------+-------------+--------+-----------+-----------+----------+---------+

    HINT: The "stdio" variation is easiest to implement -- The flex lexer accepts
          standard stream input by default. It takes extra effort to hack flex into
          using "buffer input" or "file input".

Feature Detail:

    lexer:

        flex: Use flex to generate a lexer.
              This option is preferred when regex significantly simplifies the
              lexer.

        hand-rolled: Use a custom lexer.
                     This option is preferred when speed is critical -- Flex is
                     slow. This option is also preferred when unicode support is
                     needed -- Flex has no unicode support as of the time of this
                     writing.

    input:

        buffer: Use in-memory buffer as input.
                This option is preferred when speed is critical -- Standard streams
                are slow. This option is also preferred when the input string
                already resides in memory and does not require passing through a
                standard stream in order to be used.

        stdio: Use standard input.
               This is the default behavior.

    reentrant: Tell the parser not to use global variables.
               This option is required to make the parser multi-thread compliant.

    locations: Tell the parser to provide a location variable "$@" for each BNF
               production. This option demonstrates the standard way to track syntax
               error line/column number using Flex/Bison.

    comments: Tell the lexer to conditionally enable/disable certain lexer rules for
              stateful scanning. This option demonstrates the standard way to ignore
              line/block comments.

    strings: Tell the lexer to conditionally enable/disable certain lexer rules for
             stateful scanning. This option demonstrates *one* of the many ways to
             handle strings, characters, and escaped characters.

Requirements:

    Unix tools (must be accessible from $PATH):

        gcc (with -std=c++0x support), flex, bison, valgrind, cppcheck, doxygen,
        graphviz, ticpp (static library and headers)

    Environment variables:

        $EXTERN_INCLUDE_PATH -- where "ticpp/ticpp.h" resides
        $EXTERN_LIB_PATH -- where "libticppd.a" resides

Make targets:

    all, test, pure, dot, lint, doc, xml, import, clean.

    all:    make binaries
    test:   all + run tests
    pure:   test + use valgrind to check for memory leaks
    dot:    test + generate .png graph for tests
    lint:   use cppcheck to perform static analysis on .cpp files
    doc:    use doxygen to generate documentation
    xml:    test + generate .xml for tests
    import: test + use ticpp to serialize-to/deserialize-from xml
    clean:  remove all target-generated files

FAQ:

    1. What is XLang ?
       XLang is a starting point for people looking to construct their own language
       using Lex-Yacc.

    2. What isn't XLang ?
       XLang is not unified parser front-end that will properly construct ASTs for
       every language under the sun.

    3. How should I use XLang ?
       I recommend hacking the "stdio" example to your liking, but any of the other
       variations is suitable as a base for beginners.

    4. What licenses or restrictions apply if I decide to use XLang ?
       GPL3.

    5. Why did you write XLang ?
       I owe everything I know about Lex-Yacc to Tom Niemann. Please read his
       excellent tutorial.

    6. Why allocators ?
       I've incorporated a simple memory allocator in this project because I wanted
       to keep my AST node classes as clean as possible, without destructors that
       delete child nodes. But the way the allocator was written really doesn't
       improve the program's memory usage patterns. With some effort, I suppose one
       could upgrade that into a real allocator with true memory pooling.

References:

    "Flex your lexical analysis muscles"
    http://www.codeguru.com/cpp/cpp/algorithms/strings/article.php/c12717/
    http://www.developer.com/net/cplus/article.php/3636641

    "Classic Parsing with Flex-Bison"
    http://www.codeguru.com/csharp/.net/net_general/patterns/article.php/c12805
    http://www.developer.com/net/cplus/article.php/3642516

    "Tom Niemann Flex-Bison AST examples"
    http://epaperpress.com/lexandyacc/

    "UsualCoding.eu Reentrant Flex-Bison example"
    http://www.usualcoding.eu/post/2007/09/03/Building-a-reentrant-parser-in-C-with-
    Flex/Bison
    (code example needs "void yyerror(){}" inserted in declaration section of
    parser.y)

    "Better error handling using Flex and Bison"
    http://www.ibm.com/developerworks/library/l-flexbison.html

    "ProgTools Flex-Bison AST tutorial (with classes)"
    http://www.progtools.org/compilers/tutorials/cxx_and_bison/cxx_and_bison.html

    "O-Reilly Lex-Yacc book examples"
    http://examples.oreilly.com/lex/

Additional Reading:

    http://osdir.com/ml/lex.flex.windows/2003-05/msg00017.html
    http://tldp.org/HOWTO/Lex-YACC-HOWTO-5.html
    http://net.pku.edu.cn/~course/cs201/2003/mirrorWebster.cs.ucr.edu/Page_softeng/
    softDevGuide_6.html

Keywords:

    Lex, Yacc, Flex, Bison, Parsing, C++, Reentrant C++ Parser
